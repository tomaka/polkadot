// Copyright 2018 Parity Technologies (UK) Ltd.
// This file is part of Substrate.

// Substrate is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Substrate is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Substrate.  If not, see <http://www.gnu.org/licenses/>.

use crate::custom_proto::{CustomProtos, CustomProtosHandlerOut, RegisteredProtocols};
use crate::{NetworkConfiguration, ProtocolId};
use bytes::Bytes;
use futures::prelude::*;
use libp2p::core::{Multiaddr, PeerId, swarm::NetworkBehaviourAction, swarm::NetworkBehaviourEventProcess};
use libp2p::identify::{Identify, IdentifyEvent};
use libp2p::kad::{Kademlia, KademliaOut};
use libp2p::ping::{PeriodicPing, PingListen};
use libp2p::tokio_io::{AsyncRead, AsyncWrite};
use void;

/// General behaviour of the network.
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "BehaviourEvent", poll_method = "poll")]
pub struct Behaviour<TSubstream: AsyncRead + AsyncWrite> {		// TODO: remove bounds
	/// Periodically ping nodes, and close the connection if it's unresponsive.
	periodic_ping: PeriodicPing<TSubstream>,
	/// Respond to incoming pings.
	ping_listen: PingListen<TSubstream>,
	/// Custom protocols (dot, bbq, sub, etc.).
	custom_protocols: CustomProtos<TSubstream>,
	/// Kademlia requests and answers.
	kademlia: Kademlia<TSubstream>,
	/// Periodically identifies the remote and responds to incoming requests.
	identify: Identify<TSubstream>,

	/// Queue of events to produce for the outside.
	#[behaviour(ignore)]
	events: Vec<BehaviourEvent>,
}

/// Event generated by the `Behaviour`.
pub type BehaviourEvent = (PeerId, CustomProtosHandlerOut);

impl<TSubstream> Behaviour<TSubstream> where TSubstream: AsyncRead + AsyncWrite {
	/// Builds a new `Behaviour`.
	// TODO: redundancy between config and local_peer_id
	pub fn new(config: &NetworkConfiguration, local_peer_id: PeerId, protocols: RegisteredProtocols) -> Self {
		Behaviour {
			periodic_ping: PeriodicPing::new(),
			ping_listen: PingListen::new(),
			custom_protocols: CustomProtos::new(config, protocols),
			kademlia: Kademlia::new(local_peer_id),
			identify: Identify::new(
				// The agent and protocol versions; maybe we should use something better?
				concat!("substrate/", env!("CARGO_PKG_VERSION")).to_owned(),
				concat!("substrate/", env!("CARGO_PKG_VERSION")).to_owned()
			),
			events: Vec::new(),
		}
	}

	/// Sends a message to a peer using the given custom protocol.
	///
	/// Has no effect if the custom protocol is not open with the given peer.
	///
	/// Also note that even we have a valid open substream, it may in fact be already closed
	/// without us knowing, in which case the packet will not be received.
	#[inline]
	pub fn send_custom_message(&mut self, target: &PeerId, protocol_id: ProtocolId, data: impl Into<Bytes>) {
		self.custom_protocols.send_packet(target, protocol_id, data)
	}

	/// Starts a Kademlia `FIND_NODE` query for a random `PeerId`.
	///
	/// Used to discover nodes.
	pub fn perform_kad_random_query(&mut self) {
		let random_peer_id = PeerId::random();
		debug!(target: "sub-libp2p", "Starting random Kademlia request for {:?}", random_peer_id);
		self.kademlia.find_node(random_peer_id);
	}

	/// Try to add a reserved peer.
	pub fn add_reserved_peer(&mut self, peer_id: PeerId, addr: Multiaddr) {
		self.custom_protocols.add_reserved_peer(peer_id, addr)
	}

	/// Try to remove a reserved peer.
	///
	/// If we are in reserved mode and we were connected to a node with this peer ID, then this
	/// method will disconnect it and return its index.
	pub fn remove_reserved_peer(&mut self, peer_id: PeerId) {
		self.custom_protocols.remove_reserved_peer(peer_id)
	}

	/// Start accepting all peers again if we weren't.
	pub fn accept_unreserved_peers(&mut self) {
		self.custom_protocols.accept_unreserved_peers()
	}

	/// Start refusing non-reserved nodes. Returns the list of nodes that have been disconnected.
	pub fn deny_unreserved_peers(&mut self) {
		self.custom_protocols.deny_unreserved_peers()
	}

	/// Disconnects a peer and bans it for a little while.
	///
	/// Same as `drop_node`, except that the same peer will not be able to reconnect later.
	#[inline]
	pub fn ban_node(&mut self, peer_id: PeerId) {
		// FIXME: restore
		// self.custom_protocols.ban_node(peer_id);
	}

	/// Disconnects a peer.
	///
	/// This is asynchronous and will not immediately close the peer.
	/// Corresponding closing events will be generated once the closing actually happens.
	///
	/// Has no effect if we're not connected to the `PeerId`.
	#[inline]
	pub fn drop_node(&mut self, peer_id: &PeerId) {
		// FIXME: restore
		// self.custom_protocols.drop_node(&peer_id);
	}
}

impl<TSubstream> NetworkBehaviourEventProcess<void::Void> for Behaviour<TSubstream>
where TSubstream: AsyncRead + AsyncWrite {		// TODO: remove bounds
	fn inject_event(&mut self, event: void::Void) {
		void::unreachable(event)
	}
}

impl<TSubstream> NetworkBehaviourEventProcess<(PeerId, CustomProtosHandlerOut)> for Behaviour<TSubstream>
where TSubstream: AsyncRead + AsyncWrite {		// TODO: remove bounds
	fn inject_event(&mut self, event: (PeerId, CustomProtosHandlerOut)) {
		self.events.push(event);
	}
}

impl<TSubstream> NetworkBehaviourEventProcess<IdentifyEvent> for Behaviour<TSubstream>
where TSubstream: AsyncRead + AsyncWrite {		// TODO: remove bounds
	fn inject_event(&mut self, event: IdentifyEvent) {
		match event {
			IdentifyEvent::Identified { peer_id, info, .. } => {
				trace!(target: "sub-libp2p", "Identified {:?} => {:?}", peer_id, info);
			}
			IdentifyEvent::Error { .. } => {}
		}
	}
}

impl<TSubstream> NetworkBehaviourEventProcess<KademliaOut> for Behaviour<TSubstream>
where TSubstream: AsyncRead + AsyncWrite {		// TODO: remove bounds
	fn inject_event(&mut self, _event: KademliaOut) {
		// We only ever use Kademlia for discovering nodes, and nodes discovered by Kademlia are
		// automatically added to the topology. Therefore we don't need to do anything.
	}
}

impl<TSubstream> Behaviour<TSubstream> where TSubstream: AsyncRead + AsyncWrite {		// TODO: remove bounds
	fn poll<TEv>(&mut self) -> Async<NetworkBehaviourAction<TEv, BehaviourEvent>> {
		if !self.events.is_empty() {
			return Async::Ready(NetworkBehaviourAction::GenerateEvent(self.events.remove(0)));
		}

		Async::NotReady
	}
}
